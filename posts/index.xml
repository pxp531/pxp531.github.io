<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on pxxp</title>
    <link>https://pxp531.github.io/posts/</link>
    <description>Recent content in Posts on pxxp</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 30 Aug 2024 23:05:11 +0800</lastBuildDate>
    <atom:link href="https://pxp531.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ebpf_基础01</title>
      <link>https://pxp531.github.io/posts/%E5%88%9D%E8%AF%86ebpf/</link>
      <pubDate>Fri, 30 Aug 2024 23:05:11 +0800</pubDate>
      <guid>https://pxp531.github.io/posts/%E5%88%9D%E8%AF%86ebpf/</guid>
      <description>eBPF基础01 - 整体印象 | 在工作里面用了一些eBPF的内容，抽时间总结和归纳一下&#xA;初识 eBPF eBPF 是由 BPF 发展来的，一开始使用在网络，现在还可以用在可观测性、安全等多个领域&#xA;eBPF 可以在不修改内核源码或者重新编译内核源码的情况下，对内核功能进行扩展。&#xA;对比 ko 技术，ko 需要重新编译内核，且不安全；eBPF 无需重新编译，且有verify来保证安全性，比如死循环或者非法内存访问&#xA;通过 DAG 深度优先算法来遍历 BPF 程序的代码路径，确保没有环路发生； 逐条分析 BPF 每条指令的运行，对 register 和对 stack 的影响，最坏情况下是否有越界行为 eBPF 如何保证安全&#xA;限制代码数量 &amp;amp; 总运行步数&#xA;禁止循环&#xA;verifier 必须保证 BPF 程序的所有操作必须在有限时间内完成。所以不能用循环，用循环会直接拒绝。 虽然可以采用#pragma unroll 让编译器将循环展开，如果循环次数比较多，比如说100，展开以后会多了100条指令。而verifier有指令总数限制。不过到了新版本内核支持的指令数多了，展开也还好。 限制作用域，不允许访问全局变量；如果要访问全局变量，只能借助map&#xA;&amp;hellip;&#xA;eBPF 本质 本质上是想解决内核的可编程性。”eBPF之于Linux内核就同于lua至于Nginx，都提高了可编程性和降低了门槛“。 类似于Java里面的AOP思想。 为什么需要 eBPF 对性能的追求。&#xA;比如k8s中的iptables可以搞定容器网络通信，iptables是基于链表的，所以等k8s规模上来以后性能就下来了，是O(N)的一个复杂度。ipvs是基于哈希表性能会更好点，但是集群规模越来越大性能会有瓶颈。 对内核功能扩展&#xA;比如可观测性、安全等 eBPF 流程 内核中实现了一个cBPF/eBPF虚拟机；&#xA;【第一步：编译BPF C代码】&#xA;用户态可以用 C 来写运行的代码，再通过一个 Clang&amp;amp;LLVM 的编译器将 C 代码编译成 BPF 目标码； 【第二步：加载 BPF 目标码】</description>
    </item>
  </channel>
</rss>
